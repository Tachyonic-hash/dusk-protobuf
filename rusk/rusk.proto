syntax = "proto3";
package rusk;

import "field.proto";
import "keys.proto";
import "note.proto";
import "transaction.proto";

message EchoRequest {}
message EchoResponse {}

message ValidateStateTransitionRequest {
  // List of transactions to be validated
  repeated rusk.Transaction txs = 1;
}
message ValidateStateTransitionResponse {
  // Status of the state transition
  bool success = 1;
}

message GenerateSecretKeyRequest { bytes b = 1; }

// TODO: ask what the below four structures are for
message FetchNoteRequest { fixed64 pos = 1; }

message DecryptNoteRequest {
  Note note = 1;
  ViewKey vk = 2;
}

message OwnedNotesRequest {
  ViewKey vk = 1;
  repeated Note notes = 2;
}

message OwnedNotesResponse { repeated DecryptedNote notes = 1; }

// Call from CLI directly
message NewTransactionRequest {
  SecretKey sk = 1;
  repeated DecryptedNote inputs = 2;
  PublicKey recipient = 3;
  fixed64 value = 4;
  fixed64 fee = 5;
}

message VerifyTransactionResponse {}

message VerifyTransactionRootRequest {
  Transaction transaction = 1;
  Scalar root = 2;
}
message VerifyTransactionRootResponse {}

message KeysResponse {
  ViewKey vk = 1;
  PublicKey pk = 2;
}

service Rusk {
  // Simple echo request
  rpc Echo(EchoRequest) returns (EchoResponse) {}
  // Validate a set of transactions, returning false if at least one of the
  // listed transactions is inconsistent
  rpc ValidateStateTransition(ValidateStateTransitionRequest)
      returns (ValidateStateTransitionResponse) {}

  // Phoenix stuff
  rpc GenerateSecretKey(GenerateSecretKeyRequest) returns (SecretKey) {}
  rpc Keys(SecretKey) returns (KeysResponse) {}

  rpc FetchNote(FetchNoteRequest) returns (Note) {}
  rpc DecryptNote(DecryptNoteRequest) returns (DecryptedNote) {}
  rpc OwnedNotes(OwnedNotesRequest) returns (OwnedNotesResponse) {}
  rpc FullScanOwnedNotes(ViewKey) returns (OwnedNotesResponse) {}

  rpc NewTransaction(NewTransactionRequest) returns (Transaction) {}

  rpc VerifyTransaction(Transaction) returns (VerifyTransactionResponse) {}
}
